@ifndef BORLAND WATCOM DJGPP HIGHC VISUALC LADSOFT MINGW32 MINGW64 ORANGEC CYGWIN PELLESC LCC CLANG

  This is a master makefile that will generate all makefiles.  A makefile
  for a particular system is generated by passing this through the standalone
  executable:
     ..\util\mkmake       - on plain DOS.
     ..\util\win32\mkmake - on Windows.
     ..\util\linux\mkmake - on Linux.

  For example, to produce a makefile suitable for Watcom and small model use:

      ..\util\mkmake makefile.all WATCOM SMALL > watcom_s.mak

  Currently supported compilers include:

     BORLAND, WATCOM, DJGPP, HIGHC, VISUALC, MINGW32, MINGW64, CYGWIN, PELLESC, LCC, CLANG

  Supported memory models and targets include:

     SMALL, LARGE, FLAT, WIN32, WIN64, DEBUG, RELEASE, SMALL32

  Some 32-bit DOS compilers can define these DOS-extender targets:

     PHARLAP, X32VM, DOS4GW    (otherwise all 32-bit DOS targets are FLAT)

  WATCOM wmake notes:
     A few restriction for WATCOM 'wmake' code exist if processed by 'mkmake utility':
       - To use '\' character literaly it must be followed by some character or space.
         If it is used as last character on the line then it is used as concatenation line character
       - If 'wmake' line start with '@' character, then tab character must be used on start of line
         to separate it from 'mkmake' directive line which start with '@' character too.
         But they can have only leading spaces

@else
#
# NB! THIS MAKEFILE WAS AUTOMATICALLY GENERATED FROM Makefile.all.
#     DO NOT EDIT. Edit Makefile.all and run "configur.bat" <target> instead.
#
# Makefile for the Watt-32 TCP/IP stack.
#

@ifdef VISUALC BORLAND LADSOFT LCC
!if "$(W32_BIN2C)" == ""
!error "'W32_BIN2C' is not defined. Try running 'configur.bat <target>' again."
!endif
@endif

@ifdef HIGHC DJGPP MINGW32 MINGW64 CYGWIN CLANG ORANGEC
ifeq ($(W32_BIN2C_),)
  $(error 'W32_BIN2C_' is not defined. Try running 'configur.bat <target>' again.)
endif
@endif

@ifdef ORANGEC
ifeq ($(ORANGEC),)
  $(error 'ORANGEC' is not defined. Do a 'set ORANGEC=root of your Orange-C install root'.)
endif
@endif

@ifdef BORLAND
!if "$(BCCDIR)" == ""
!error "'BCCDIR' is not defined. Do a 'set BCCDIR=root of your Borland (or CBuilder) install root'."
!endif
@endif

@ifdef WATCOM
!ifdef %W32_BIN2C
W32_BIN2C = $(%W32_BIN2C)
!else ifdef __LINUX__
W32_BIN2C = ../util/linux/bin2c
!else
!error W32_BIN2C is not defined. Try running 'configur.bat watcom' again.
!endif
!ifdef %W32_NASM
W32_NASM = $(%W32_NASM)
!else ifdef __LINUX__
W32_NASM = nasm
!endif
@endif

ASM_SOURCE = asmpkt.asm cpumodel.asm

CORE_SOURCE = bsdname.c  btree.c    chksum.c   country.c  crc.c      dynip.c    \
              echo.c     fortify.c  getopt.c   gettod.c   highc.c    idna.c     \
              ip4_frag.c ip4_in.c   ip4_out.c  ip6_in.c   ip6_out.c  language.c \
              lookup.c   loopback.c misc.c     netback.c  oldstuff.c packet32.c \
              pc_cbrk.c  pcarp.c    pcbootp.c  pcbuf.c    pcconfig.c pcdbug.c   \
              pcdhcp.c   pcdns.c    pcicmp.c   pcicmp6.c  pcigmp.c   pcintr.c   \
              pcping.c   pcpkt.c    pcpkt32.c  pcqueue.c  pcrarp.c   pcrecv.c   \
              pcsed.c    pcstat.c   pctcp.c    ports.c    powerpak.c ppp.c      \
              pppoe.c    profile.c  punycode.c qmsg.c     run.c      settod.c   \
              sock_dbu.c sock_in.c  sock_ini.c sock_io.c  sock_prn.c sock_scn.c \
              sock_sel.c split.c    misc_str.c swsvpkt.c  tcp_fsm.c  tcp_md5.c  \
              tftp.c     timer.c    udp_rev.c  version.c  wdpmi.c    win_dll.c  \
              winadinf.c winmisc.c  winpkt.c   x32vm.c

BSD_SOURCE =  accept.c   bind.c     bsddbug.c  close.c    connect.c  fcntl.c    \
              fsext.c    get_ai.c   get_ip.c   get_ni.c   get_xbyr.c geteth.c   \
              gethost.c  gethost6.c getname.c  getnet.c   getprot.c  getput.c   \
              getserv.c  ioctl.c    linkaddr.c listen.c   netaddr.c  neterr.c   \
              nettime.c  nsapaddr.c poll.c     presaddr.c printk.c   receive.c  \
              select.c   shutdown.c signal.c   socket.c   sockopt.c  stream.c   \
              syslog.c   syslog2.c  transmit.c

BIND_SOURCE = res_comp.c res_data.c res_debu.c res_init.c res_loc.c res_mkqu.c \
              res_quer.c res_send.c

ZLIB_SOURCE = zadler32.c  zcompres.c zcrc32.c   zgzio.c \
              zuncompr.c  zdeflate.c ztrees.c   zutil.c \
              zinflate.c  zinfback.c zinftree.c zinffast.c

C_SOURCE = $(CORE_SOURCE) $(BSD_SOURCE) $(BIND_SOURCE) $(ZLIB_SOURCE)

COMMON_OBJS = \
@ifndef LCC WIN64
       $(OBJPATH)cpumodel.obj  \
@endif
       $(OBJPATH)accept.obj   $(OBJPATH)bind.obj      \
       $(OBJPATH)bsddbug.obj  $(OBJPATH)bsdname.obj   \
       $(OBJPATH)btree.obj    $(OBJPATH)chksum.obj    \
       $(OBJPATH)close.obj    $(OBJPATH)connect.obj   \
       $(OBJPATH)crc.obj      $(OBJPATH)dynip.obj     \
       $(OBJPATH)echo.obj     $(OBJPATH)fcntl.obj     \
       $(OBJPATH)fortify.obj  $(OBJPATH)get_ai.obj    \
       $(OBJPATH)get_ip.obj   $(OBJPATH)get_ni.obj    \
       $(OBJPATH)get_xbyr.obj $(OBJPATH)geteth.obj    \
       $(OBJPATH)gethost.obj  $(OBJPATH)gethost6.obj  \
       $(OBJPATH)getname.obj  $(OBJPATH)getnet.obj    \
       $(OBJPATH)getopt.obj   $(OBJPATH)getprot.obj   \
       $(OBJPATH)getput.obj   $(OBJPATH)getserv.obj   \
       $(OBJPATH)gettod.obj   $(OBJPATH)idna.obj      \
       $(OBJPATH)ioctl.obj    $(OBJPATH)ip4_frag.obj  \
       $(OBJPATH)ip4_in.obj   $(OBJPATH)ip4_out.obj   \
       $(OBJPATH)ip6_in.obj   $(OBJPATH)ip6_out.obj   \
       $(OBJPATH)language.obj $(OBJPATH)linkaddr.obj  \
       $(OBJPATH)listen.obj   $(OBJPATH)lookup.obj    \
       $(OBJPATH)loopback.obj $(OBJPATH)misc.obj      \
       $(OBJPATH)netaddr.obj  $(OBJPATH)netback.obj   \
       $(OBJPATH)neterr.obj   $(OBJPATH)nettime.obj   \
       $(OBJPATH)nsapaddr.obj $(OBJPATH)oldstuff.obj  \
       $(OBJPATH)packet32.obj $(OBJPATH)pc_cbrk.obj   \
       $(OBJPATH)pcarp.obj    $(OBJPATH)pcbootp.obj   \
       $(OBJPATH)pcbuf.obj    $(OBJPATH)pcconfig.obj  \
       $(OBJPATH)pcdbug.obj   $(OBJPATH)pcdhcp.obj    \
       $(OBJPATH)pcdns.obj    $(OBJPATH)pcicmp.obj    \
       $(OBJPATH)pcicmp6.obj  $(OBJPATH)pcigmp.obj    \
       $(OBJPATH)pcping.obj   $(OBJPATH)pcqueue.obj   \
       $(OBJPATH)pcrarp.obj   $(OBJPATH)pcrecv.obj    \
       $(OBJPATH)pcsed.obj    $(OBJPATH)pcstat.obj    \
       $(OBJPATH)pctcp.obj    $(OBJPATH)poll.obj      \
       $(OBJPATH)ports.obj    $(OBJPATH)ppp.obj       \
       $(OBJPATH)pppoe.obj    $(OBJPATH)presaddr.obj  \
       $(OBJPATH)printk.obj   $(OBJPATH)profile.obj   \
       $(OBJPATH)punycode.obj $(OBJPATH)receive.obj   \
       $(OBJPATH)res_comp.obj $(OBJPATH)res_data.obj  \
       $(OBJPATH)res_debu.obj $(OBJPATH)res_init.obj  \
       $(OBJPATH)res_loc.obj  $(OBJPATH)res_mkqu.obj  \
       $(OBJPATH)res_quer.obj $(OBJPATH)res_send.obj  \
       $(OBJPATH)run.obj      $(OBJPATH)select.obj    \
       $(OBJPATH)settod.obj   $(OBJPATH)shutdown.obj  \
       $(OBJPATH)signal.obj   $(OBJPATH)sock_dbu.obj  \
       $(OBJPATH)sock_in.obj  $(OBJPATH)sock_ini.obj  \
       $(OBJPATH)sock_io.obj  $(OBJPATH)sock_prn.obj  \
       $(OBJPATH)sock_scn.obj $(OBJPATH)sock_sel.obj  \
       $(OBJPATH)socket.obj   $(OBJPATH)sockopt.obj   \
       $(OBJPATH)split.obj    $(OBJPATH)stream.obj    \
       $(OBJPATH)misc_str.obj $(OBJPATH)swsvpkt.obj   \
       $(OBJPATH)syslog.obj   $(OBJPATH)syslog2.obj   \
       $(OBJPATH)tcp_fsm.obj  $(OBJPATH)tcp_md5.obj   \
       $(OBJPATH)tftp.obj     $(OBJPATH)timer.obj     \
       $(OBJPATH)transmit.obj $(OBJPATH)udp_rev.obj   \
       $(OBJPATH)version.obj  $(OBJPATH)zadler32.obj  \
       $(OBJPATH)zcompres.obj $(OBJPATH)zcrc32.obj    \
       $(OBJPATH)zdeflate.obj $(OBJPATH)zgzio.obj     \
       $(OBJPATH)zinfback.obj $(OBJPATH)zinffast.obj  \
       $(OBJPATH)zinflate.obj $(OBJPATH)zinftree.obj  \
       $(OBJPATH)ztrees.obj   $(OBJPATH)zuncompr.obj  \
       $(OBJPATH)zutil.obj

WINDOWS_OBJS = $(OBJPATH)win_dll.obj  \
               $(OBJPATH)winadinf.obj \
               $(OBJPATH)winmisc.obj  \
               $(OBJPATH)winpkt.obj

#
# These object are only possible for DOS (16/32-bit).
# So never add them to Library programs for Windows targets.
#
# This is to prevent warnings like these from MSVC's link:
#   qmsg.obj : warning LNK4221: This object file does not define any previously undefined public
#              symbols, so it will not be used by any link operation that consumes this library
#

DOS_OBJS = \
@ifdef SMALL LARGE
           $(OBJPATH)asmpkt.obj   \
@endif
           $(OBJPATH)country.obj  \
           $(OBJPATH)fsext.obj    \
           $(OBJPATH)pcpkt32.obj  \
           $(OBJPATH)pcpkt.obj    \
           $(OBJPATH)pcintr.obj   \
           $(OBJPATH)powerpak.obj \
           $(OBJPATH)qmsg.obj     \
           $(OBJPATH)wdpmi.obj    \
           $(OBJPATH)x32vm.obj

#
# CPU, bit-width and suffix.
# Not used for any DOS targets.
#
@ifdef WIN64
CPU    = x64
BITS   = 64
SUFFIX = _64
@else
CPU    = x86
BITS   = 32
SUFFIX =
@endif

@ifdef WIN32 WIN64
#
# For all 32/64-bit Windows targets:
#
OBJS = $(COMMON_OBJS) $(WINDOWS_OBJS)

@ifdef VISUALC
OBJS = $(OBJS) $(OBJPATH)stkwalk.obj
@endif

@ifdef CLANG ORANGEC
OBJS += $(OBJPATH)stkwalk.obj
@endif

@else
#
# For all 16/32-bit DOS targets:
#
OBJS = $(COMMON_OBJS) $(DOS_OBJS)
@endif

@ifdef FLAT SMALL32
#
# This generated file is used for all 32-bit MSDOS targets
# (and when USE_FAST_PKT is defined). This enables a faster real-mode
# callback for the PKTDRVR receiver. Included as an array in pcpkt2.c.
#
PKT_STUB = pkt_stub.h
@endif

########################################################################

@ifdef DJGPP
#
# Only used by 'make -f djgpp install':
#
prefix = /dev/env/DJDIR/net/watt

CFLAGS = -O3 -g -I. -I../inc -DWATT32_BUILD -W -Wall -Wno-strict-aliasing \
         -march=i386 -mtune=i586

STAT_LIB = ../lib/libwatt.a
OBJDIR   = build/djgpp
OBJPATH  = $(OBJDIR)/

CC     = $(BIN_PREFIX)gcc
AR     = $(BIN_PREFIX)ar rs
AS     = $(BIN_PREFIX)as
AFLAGS = # --gdwarf2

ifeq ($(filter 2 3 4,$(word 3, $(shell true | $(CC) -E -dD -x c - | grep 'define\ *__GNUC__'))),)
  #
  # We have gcc >= 5.x and we must ensure that always traditional
  # GNU extern inline semantics are used (aka -fgnu89-inline) even
  # if ISO C99 semantics have been specified.
  #
  CFLAGS += -fgnu89-inline
endif

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS   = $(OBJPATH)gcc.arg
LIB_ARGS = $(OBJPATH)ar.arg

TARGETS = $(STAT_LIB)

all: $(PKT_STUB) $(OBJPATH)cflags.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

$(OBJPATH)%.o: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) -o $@ $<

$(OBJPATH)%.o: %.S $(C_ARGS)
	$(CC) -E @$(C_ARGS) $< > $(OBJPATH)$*.iS
	$(AS) $(AFLAGS) $(OBJPATH)$*.iS -o $@

$(OBJPATH)cpumodel.o: cpumodel.S

install: all
	- mkdir -p "$(prefix)/inc"
	- mkdir -p "$(prefix)/lib"
	cp -fr ../inc "$(prefix)"
	cp -fr ../lib "$(prefix)"
	@echo Install to $(prefix) done

clean:
	rm -f $(TARGETS) $(OBJPATH)*.o $(OBJPATH)*.iS $(OBJPATH)*.arg $(PKT_STUB) $(OBJPATH)cflags.h
	@echo Cleaning done

-include build/djgpp/watt32.dep

########################################################################

@elifdef BORLAND

LIBFLAGS = /C /E /u

@ifdef SMALL
CC        = bcc
CFLAGS    = -ms -H -H=$(TEMP)\bcc_s.pch -f- -Z
AFLAGS    = -mx -m2 -t -l
STAT_LIB  = ..\lib\wattcpbs.lib
OBJDIR    = build\borland\small
C_ARGS    = $(OBJPATH)bcc.arg
MAKE_FILE = bcc_s.mak

@elifdef LARGE
CC        = bcc
CFLAGS    = -ml -H -H=$(TEMP)\bcc_l.pch -f- -Z
AFLAGS    = -mx -m2 -t -l
STAT_LIB  = ..\lib\wattcpbl.lib
LIBFLAG   = $(LIBFLAGS) /P32
OBJDIR    = build\borland\large
C_ARGS    = $(OBJPATH)bcc.arg
MAKE_FILE = bcc_l.mak

@elifdef FLAT
CC = f:\gv\Borland55\Bin\bcc32
#
# This is just a test. Old 'bcc32' such as the above v5.5 will no
# longer work in Watt-32. So dropping support for Borland (small, large, flat) is imminent.
#
CFLAGS    = -4- -RT- -O2 -H -H=$(TEMP)\bcc_f.pch -D_M_IX86=1 -D__BORLANDC__=0x0550
AFLAGS    = -mx -m2 -t -l -DDOSX
STAT_LIB  = ..\lib\wattcpbf.lib
LIBFLAG   = $(LIBFLAGS) /P32
OBJDIR    = build\borland\flat
C_ARGS    = $(OBJPATH)bcc32.arg
MAKE_FILE = bcc_f.mak

@elifdef WIN32
#
# Since CBuilder 10 (I think), the 32-bit compiler is based on LLVM and
# it's name changed from 'bcc32.exe' to 'bcc32c.exe'.
# Ditto for 'cpp32.exe'  (the C/C++ preprocessor).
#
# Borland is now a product of "Embarcadero Technologies, Inc."
#
# Change the 'bcc32c' back to 'bcc32' to suite your version of CBuilder.
# Or create an env-var "CBUILDER_IS_LLVM_BASED=1".
#
!if "$(CBUILDER_IS_LLVM_BASED)" == ""
  CC     = $(BCCDIR)\bin\bcc32
  C_ARGS = $(OBJPATH)bcc32.arg

  #
  # -5:  Use Pentium instructions.
  # -WM: Create Windows application.
  # -Vd: Virtual table control, disable
  # -H:  Use pre-compiled headers. '-H=xx' names the file.
  #
  CFLAGS = -5 -WM -Vd -H -H=$(TEMP)\bcc_w.pch

  #
  # Borland's Resource Compiler:
  #
  BRC32 = $(BCCDIR)\bin\brc32
!else
  CC     = $(BCCDIR)\bin\bcc32c
  C_ARGS = $(OBJPATH)bcc32c.arg
  CFLAGS = # -fcolor-diagnostics-
  BRC32  = $(BCCDIR)\bin\rc
!endif

#
# -RT-: Generate RTTI, disable
#
CFLAGS = $(CFLAGS) -RT-

#
# Turn off some noise from Win-SDK headers.
#
CFLAGS = $(CFLAGS) -DBUILD_WINDOWS

#
# Hacks for compiling the generated lang.c file:
#  Since CBuilder defines '__STDC_VERSION__', and Flex emits a "#include <inttypes.h>"
#  if 'FLEXINT_H' is not defined and '__STDC_VERSION__' is '>= 199901L'.
#  But no Borland version I have seen do have '<inttypes.h>'.
#
CFLAGS = $(CFLAGS) -DFLEXINT_H -Dflex_int32_t=int -Dflex_int16_t=short -Dflex_uint8_t=int

AFLAGS = -mx -m2 -t -l -DDOSX

STAT_LIB  = ..\lib\wattcpbw.lib
IMP_LIB   = ..\lib\wattcpbw_imp.lib
WATT_DLL  = ..\bin\watt-32.dll
LIBFLAG   = $(LIBFLAGS) /P64
RESOURCE  = $(OBJPATH)watt-32.res
OBJDIR    = build\borland\win32
MAKE_FILE = bcc_w.mak

@else
!error Unknown BORLAND model
@endif

OBJPATH = $(OBJDIR)\ #

!if "$(CBUILDER_IS_LLVM_BASED)" == ""
  CFLAGS = $(CFLAGS) -w-aus- -w-pia- -w-csu-
!endif

CFLAGS  = $(CFLAGS) -q -c -O -v -vi- -d -Tt -w  -I. -I..\inc -n$(OBJDIR) -DWATT32_BUILD
LDFLAGS = -tWD -lM -lm -q -lq -laa -lc

AS = tasm32

.SWAP

@ifdef WIN32
TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)
@else
TARGETS = $(STAT_LIB)
@endif

all: $(PKT_STUB) $(C_ARGS) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS)
	$(BCCDIR)\bin\tlib $(STAT_LIB) $(LIBFLAG) @&&|
	  $(OBJS)
|
	- @del $(STAT_LIB:.lib=.bak)

@ifdef WIN32
$(IMP_LIB): $(WATT_DLL)

$(WATT_DLL): $(OBJS) $(RESOURCE) $(OBJPATH)objects.arg
	- @del $(WATT_DLL)
	- @del $(IMP_LIB)
	$(CC) $(LDFLAGS) -e$(WATT_DLL) @$(OBJPATH)objects.arg
	$(BCCDIR)\bin\implib $(IMP_LIB) $(WATT_DLL)
	- @del $(WATT_DLL:.dll=.tds)
	@echo

$(OBJPATH)objects.arg: $(MAKE_FILE)
	@copy &&|
	 $(OBJS) $(RESOURCE)
| $(OBJPATH)objects.arg

@endif

$(C_ARGS): $(MAKE_FILE)
	@copy &&|
	  $(CFLAGS)
| $<

$(OBJPATH)asmpkt.obj:   asmpkt.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c.obj:
	$(CC) @$(C_ARGS) $*.c

.asm.obj:
	$(AS) $(AFLAGS) $*.asm, $(OBJPATH)$*.obj

clean:
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)*.asm
@ifdef WIN32
	- @del $(RESOURCE)
@endif
	- @del $(OBJPATH)*.arg
	- @del asmpkt.lst
	- @del $(TARGETS)
	- @del $(TEMP)\bcc_?.pch
!ifdef PKT_STUB
	- @del $(PKT_STUB)
!endif
	@echo Cleaning done

!include "build\borland\watt32.dep"

########################################################################

@elifdef WATCOM

.ERASE

.EXTENSIONS: .l

!ifdef __UNIX__
LIBPATH = ../lib/
DLLPATH = ../bin/
OBJROOT = build/watcom/
OBJPATH = $(OBJDIR)/
RM = rm -f
!else
LIBPATH = ..\lib\ #
DLLPATH = ..\bin\ #
OBJROOT = build\watcom\ #
OBJPATH = $(OBJDIR)\ #
RM = del
!endif

AS = *wasm
AR = *wlib

@ifdef SMALL
CC       = *wcc
CFLAGS   = -bt=dos -ms -0 -os -s -zc -zm -zlf -DWATT32_STATIC
AFLAGS   = -bt=dos
STAT_LIB = $(LIBPATH)wattcpws.lib
OBJDIR   = $(OBJROOT)small
I_CFLAGS = -I"$(%WATCOM)/h"

@elifdef LARGE
CC       = *wcc
CFLAGS   = -bt=dos -ml -0 -os -s -zc -zm -zlf -DWATT32_STATIC
AFLAGS   = -bt=dos
STAT_LIB = $(LIBPATH)wattcpwl.lib
OBJDIR   = $(OBJROOT)large
I_CFLAGS = -I"$(%WATCOM)/h"

@elifdef FLAT
CC       = *wcc386
CFLAGS   = -bt=dos -mf -3r -zff -zgf -oilrtfm -s -zlf -DWATT32_STATIC
AFLAGS   = -bt=dos -3r -dDOSX -dDOS4GW
STAT_LIB = $(LIBPATH)wattcpwf.lib
OBJDIR   = $(OBJROOT)flat
I_CFLAGS = -I"$(%WATCOM)/h" # -I"$(%PHARLAP)/include"

@elifdef WIN32
CC       = *wcc386
CFLAGS   = -bt=nt -mf -3r -fp6 -oilrtfm -s -bm -zri -zlf
AFLAGS   = -bt=nt -3s -dDOSX
LDFLAGS  = system nt_dll
STAT_LIB = $(LIBPATH)wattcpww.lib
IMP_LIB  = $(LIBPATH)wattcpww_imp.lib
WATT_DLL = $(DLLPATH)watt-32.dll
OBJDIR   = $(OBJROOT)win32
RESOURCE = $(OBJPATH)watt-32.res
I_CFLAGS = -I"$(%WATCOM)/h" -I"$(%WATCOM)/h/nt"

@elifdef SMALL32
CC       = *wcc386
CFLAGS   = -bt=dos -ms -3r -oaxt -s -zlf -DWATT32_STATIC
AFLAGS   = -bt=dos -3s -dDOSX -dDOS4GW
STAT_LIB = $(LIBPATH)wattcpw3.lib
OBJDIR   = $(OBJROOT)small32
I_CFLAGS = -I"$(%WATCOM)/h"

@else
!error Unknown WATCOM model
@endif

LIB_ARGS  = $(OBJPATH)wlib.arg
LINK_ARGS = $(OBJPATH)wlink.arg
C_ARGS    = $(OBJPATH)wcc.arg

AFLAGS += -zq -w3 -d1 -I"../inc"
CFLAGS += -zq -wx -DWATT32_BUILD -I. -I"../inc"
@ifdef DEBUG
CFLAGS += -d2
@else
CFLAGS += -d1
@endif

#
# WCC386-flags used:
#   -bt=dos   target system - DOS
#   -bt=nt    target system - Win-NT
#   -m{s,f}   memory model; small or flat
#   -3s       optimise for 386, stack call convention
#   -3r       optimise for 386, register call convention
#   -s        no stack checking
#   -zq       quiet compiling
#   -d{1,2,3} generate debug info
#   -zlf      always generate default library information
#   -zm       place each function in separate segment
#   -oilrtfm  optimization flags
#     i:      expand intrinsics
#     l:      loop optimisations
#     r:      reorder instructions
#     t:      favor execution time
#     f:      always use stack frames
#     m:      generate inline code for math functions
#
#  This should make the smallest code on a 386
#    -oahkrs -s -em -zp1 -3r -fp3
#
#  WCC-flags for small/large model:
#   -bt=dos   target system - DOS
#   -m{s,l}   memory model; small or large
#   -0        optimise for 8086, register call convention
#   -s        no stack checking
#   -zq       quiet compiling
#   -zc       place const data into the code segment
#   -d{1,2,3} generate debug info
#   -os       optimization flags
#     s:      favour code size over execution time
#

@ifdef WIN32
TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)
@else
TARGETS = $(STAT_LIB)
@endif

all: $(PKT_STUB) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)

@ifdef WIN32
$(IMP_LIB): $(WATT_DLL)
	@%null

$(WATT_DLL): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	*wlink $(LDFLAGS) name $^@ @$(LINK_ARGS)
@endif

$(STAT_LIB): $(OBJS) $(LIB_ARGS)
	$(AR) -q -b -c -pa -z=export.tmp $^@ @$(LIB_ARGS)

$(OBJPATH)language.obj: language.c lang.c
$(OBJPATH)asmpkt.obj:   asmpkt.asm
$(OBJPATH)cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj: .AUTODEPEND $(C_ARGS)
	$(CC) @$(C_ARGS) $[@ -fo=$^@

.asm{$(OBJDIR)}.obj: .AUTODEPEND
	$(AS) $(AFLAGS) $[@ -fo=$^@

$(C_ARGS): $(__MAKEFILES__)
	%create $^@
	@%append $^@ $(CFLAGS) $(I_CFLAGS)

$(LIB_ARGS): $(__MAKEFILES__)
	%create $^@
	@for %f in ($(OBJS)) do @%append $^@ +- %f

@ifdef WIN32
$(LINK_ARGS): $(__MAKEFILES__)
	%create $^@
	@%append $^@ option quiet, verbose
	@%append $^@ debug all
	@%append $^@ opt map=$(WATT_DLL:.dll=.map)
	@%append $^@ opt implib=$(IMP_LIB), res=$(RESOURCE)
	@%append $^@ reference __DLLstart_
	@for %f in ($(OBJS)) do @%append $^@ file %f
@endif

clean: .SYMBOLIC
	@if exist $(OBJPATH)*.obj $(RM) $(OBJPATH)*.obj
	@if exist $(OBJPATH)cflags.h $(RM) $(OBJPATH)cflags.h
	@if exist $(OBJPATH)cflagsbf.h $(RM) $(OBJPATH)cflagsbf.h
	@if exist $(STAT_LIB) $(RM) $(STAT_LIB)
	@if exist $(C_ARGS)   $(RM) $(C_ARGS)
	@if exist $(LIB_ARGS) $(RM) $(LIB_ARGS)
	@if exist export.tmp  $(RM) export.tmp
!ifdef PKT_STUB
	@if exist $(PKT_STUB) $(RM) $(PKT_STUB)
!endif
@ifdef WIN32
	@if exist $(LINK_ARGS) $(RM) $(LINK_ARGS)
	@if exist $(WATT_DLL)  $(RM) $(WATT_DLL)
	@if exist $(IMP_LIB)   $(RM) $(IMP_LIB)
	@if exist $(RESOURCE)  $(RM) $(RESOURCE)
	@if exist $(WATT_DLL:.dll=.map) $(RM) $(WATT_DLL:.dll=.map)
@endif
	@echo Cleaning done

########################################################################

@elifdef VISUALC

#
# A perculiar feature (or bug?) with the MS linker is that the import
# libs (..\lib\$(CPU)\wattcpvc_imp.lib + ..\lib\$(CPU)\wattcpvc_imp_d.lib) can get
# older than the target .dll they represent. Hence the below 'touch'
# commands.
#
# Special <crtdefs.h> defines:
#  _CRT_SECURE_NO_WARNINGS
#  _CRT_SECURE_NO_DEPRECATE
#  _CRT_SECURE_NO_WARNINGS_GLOBALS
#  _CRT_NONSTDC_NO_WARNINGS
#  _CRT_OBSOLETE_NO_WARNINGS
#
# Note: 'cdecl' (-Gd) is default. Check if '__fastcall' (-Gr) in '_DEBUG' mode
#       is possible.
#
# The Microsoft Macro Assembler (ml and ml64) is no longer available as
# a separate download. It must be downloaded as part of "Visual Studio"
# or the "Build Tools for Visual Studio":
#   https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022
#
CFLAGS = -nologo -Zi -W3 -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -I. -I../inc

LDFLAGS = -machine:$(CPU)

#
# Do not use the so called "POSIX supplemented" error-codes.
# They are of little use since a 'strerror(x)' always returns
# "unknown error" for these.
#
# CFLAGS = $(CFLAGS) -D_CRT_NO_POSIX_ERROR_CODE

@ifdef DEBUG
CFLAGS = $(CFLAGS) -MDd -Ot -D_DEBUG -EHsc -RTCc -RTCs -RTCu -GF -GS # -Gr
@else
CFLAGS = $(CFLAGS) -MD -Ox -GS- # -Gr
@endif

@ifdef WIN64
AS     = ml64
AFLAGS = -c -nologo -DDOSX -DWIN64 -Zi
@else
#
# WIN32
#
AS     = ml
AFLAGS = -c -nologo -DDOSX -Zi -coff
@endif

@ifdef DEBUG
STAT_LIB  = ..\lib\$(CPU)\wattcpvc_d.lib
IMP_LIB   = ..\lib\$(CPU)\wattcpvc_imp_d.lib
WATT_DLL  = ..\bin\watt-32d$(SUFFIX).dll
OBJDIR    = build\visualc\$(BITS)bit\debug
MAKE_FILE = visualc-debug_$(BITS).mak

@else
STAT_LIB  = ..\lib\$(CPU)\wattcpvc.lib
IMP_LIB   = ..\lib\$(CPU)\wattcpvc_imp.lib
WATT_DLL  = ..\bin\watt-32$(SUFFIX).dll
OBJDIR    = build\visualc\$(BITS)bit\release
MAKE_FILE = visualc-release_$(BITS).mak
@endif

OBJPATH = $(OBJDIR)\ #

#
# TODO:
#   Use 'CC=$(VCToolkitInstallDir)\bin\Hostx86\$(CPU)\cl.exe'
#   Use 'LDFLAGS=-libpath:$(VCToolkitInstallDir)\lib\$(CPU) \
#                -libpath:$(WindowsSdkDir)\lib\$(TargetPlatformVersion)\ucrt\$(CPU) \
#                -libpath:$(WindowsSdkDir)\lib\$(TargetPlatformVersion)\um\$(CPU)'
#
CC      = cl
LDFLAGS = -dll -nologo -map -debug -debugtype:cv -incremental:no -verbose $(LDFLAGS)

#
# The 'lib' command common to MSVC: Win32/Win64
#
AR = lib -nologo -ignore:4221

#
# Ignore warning:
#   xyz.obj : warning LNK4221: This object file does not define any previously undefined
#   public symbols, so it will not be used by any link operation that consumes this library
#
# May not be supported by all 'link' versions.
#
LDFLAGS = $(LDFLAGS) -ignore:4221

#
# Enable the watt-32.dll to be used on Win-XP SP3 (5.2) in case
# it was built under Win-Vista+
#
LDFLAGS   = $(LDFLAGS) -subsystem:console,5.02

EX_LIBS   = user32.lib advapi32.lib
RESOURCE  = $(OBJPATH)watt-32.res
C_ARGS    = $(OBJPATH)cl.arg
LINK_ARGS = $(OBJPATH)link.arg

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(C_ARGS) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(C_ARGS): $(MAKE_FILE)
	@echo -c $(CFLAGS) > $@

$(LINK_ARGS): $(MAKE_FILE)
	@echo $(OBJS) $(RESOURCE) $(EX_LIBS) > $@

#
# Static libs
#
$(STAT_LIB): $(OBJS)
	$(AR) -machine:$(CPU) -out:$@ @<<
	 $**
<<

#
# Import libs + DLLs
#
$(WATT_DLL) $(IMP_LIB): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	link $(LDFLAGS) -out:$(WATT_DLL) -implib:$(IMP_LIB) @$(LINK_ARGS) > link.tmp
	type link.tmp >> $(WATT_DLL:.dll=.map)
	@del $(IMP_LIB:.lib=.exp)
	touch $(IMP_LIB)

$(OBJPATH)cpumodel.obj: cpumodel.asm

.cpp{$(OBJDIR)}.obj:
	$(CC) @$(C_ARGS) -EHsc -Fo.\$*.obj $<

.c{$(OBJDIR)}.obj:
	$(CC) @$(C_ARGS) -Fo.\$*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) -Fo.\$*.obj -Fl.\$*.lst $<

!include build\visualc\watt32.dep

clean:
	- @del $(TARGETS)
	- @del $(C_ARGS) $(LINK_ARGS)
	- @del $(OBJPATH)*.obj $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h
	- @del $(OBJPATH)*.lst
	- @del $(RESOURCE)
	- @del vc1*.pdb $(IMP_LIB:.lib=.exp) $(WATT_DLL:.dll=.pdb)
	@echo Cleaning done

########################################################################

@elifdef LCC

@ifndef WIN32
!error The only possible target for LCC is WIN32
@endif

CC        = lcc
CFLAGS    = -g2 -O -A -I. -I../inc -DWATT32_BUILD
STAT_LIB  = ..\lib\wattcp_lcc.lib
IMP_LIB   = ..\lib\wattcp_lcc_imp.lib
WATT_DLL  = ..\bin\watt-32.dll
MAKE_FILE = lcc.mak
OBJDIR    = build\lcc
OBJPATH   = $(OBJDIR)\ #

AS       = tasm32
AFLAGS   = -DDOSX -mx -m2 -t -l
LDFLAGS  = -subsystem console -dll -dynamic
EX_LIBS  = user32.lib advapi32.lib
RESOURCE = $(OBJPATH)watt-32.res

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS)
	@echo Generating $(STAT_LIB) ...
	@cd $(OBJDIR)
	@for %f in (*.obj) do lcclib ..\..\$(STAT_LIB) %f
	@cd ..\..

#
# Import lib + DLL (debug)
#
$(WATT_DLL) $(IMP_LIB): $(OBJS)
	lcclnk $(LDFLAGS) -o $(WATT_DLL) -map watt-32.map $(OBJS) $(EX_LIBS)
	implib $(IMP_LIB) $(WATT_DLL)

$(OBJPATH)cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) -c $(CFLAGS) -o $*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) $<, $*.obj

!include build\lcc\watt32.dep

clean:
	- @del $(TARGETS)
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)cflagsbf.h
	- @del $(RESOURCE)
	- @del *.lst
	@echo Cleaning done

########################################################################

@elifdef CLANG

CC     = clang-cl
CFLAGS = -nologo -Zi -Zo -GS- -I. -I../inc \
         -DWATT32_BUILD                    \
         -D_CRT_SECURE_NO_WARNINGS         \
         -D_CRT_NONSTDC_NO_WARNINGS        \
         -D_CRT_OBSOLETE_NO_WARNINGS       \
         -D_WIN32_WINNT=0x0601             \
         -D_WINSOCK_DEPRECATED_NO_WARNINGS \
         -DBUILD_WINDOWS

CFLAGS += -Wno-\#pragma-messages

@ifdef DEBUG
  CFLAGS += -MDd
@else
  CFLAGS += -MD -Ox
@endif

#
# Enable full Microsoft Visual C++ compatibility
#
CFLAGS += -fms-compatibility
LDFLAGS = -dll -nologo -map -debug -debugtype:cv -incremental:no -verbose

#
# The 'lib' command common to Win32/Win64
#
AR = lib -nologo

#
# Ignore warning:
#   xyz.obj : warning LNK4221: This object file does not define any previously undefined
#   public symbols, so it will not be used by any link operation that consumes this library
#
# May not be supported by all 'lib' and 'link' versions.
#
LDFLAGS += -ignore:4221
AR      += -ignore:4221

#
# Enable the watt-32.dll to be used on Win-XP SP3 (5.2) in case
# it was built under Win-Vista+
#
LDFLAGS += -subsystem:console,5.02

EX_LIBS  = user32.lib advapi32.lib

@ifdef DEBUG
STAT_LIB = ../lib/$(CPU)/wattcp_clang_d.lib
IMP_LIB  = ../lib/$(CPU)/wattcp_clang_imp_d.lib
WATT_DLL = ../bin/watt-32$(SUFFIX)d.dll
OBJDIR   = build/clang/$(BITS)bit/debug
@else
STAT_LIB = ../lib/$(CPU)/wattcp_clang.lib
IMP_LIB  = ../lib/$(CPU)/wattcp_clang_imp.lib
WATT_DLL = ../bin/watt-32$(SUFFIX).dll
OBJDIR   = build/clang/$(BITS)bit/release
@endif

OBJPATH  = $(OBJDIR)/
RESOURCE = $(OBJPATH)watt-32.res

@ifdef WIN64
  AS     = ml64
  AFLAGS = -c -nologo -DDOSX -Zi -DWIN64
@else
  AS     = ml
  AFLAGS = -c -nologo -DDOSX -Zi -coff
@endif

C_ARGS    = $(OBJPATH)clang.arg
LIB_ARGS  = $(OBJPATH)lib.arg
LINK_ARGS = $(OBJPATH)link.arg

#
# In case '%CL%' is set, it may confuse 'clang-cl'. Unset it.
#
export CL=

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

#
# Static library rules:
#
$(STAT_LIB): $(OBJS) $(LIB_ARGS)
	$(AR) -machine:$(CPU) -out:$@ @$(LIB_ARGS)

#
# Import lib + DLLs (release, debug)
#
$(IMP_LIB): $(WATT_DLL)

$(WATT_DLL): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	link $(LDFLAGS) -machine:$(CPU) -out:$@ -implib:$(IMP_LIB) @$(LINK_ARGS) > link.tmp
	cat link.tmp >> $(WATT_DLL:.dll=.map)
	rm -f $(IMP_LIB:.lib=.exp)

$(OBJPATH)%.obj: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) -Fo./$@ $<

$(OBJPATH)%.obj: %.cpp $(C_ARGS)
	$(CC) -TP -EHsc @$(C_ARGS) -Fo./$@ $<

$(OBJPATH)%.obj: %.asm
	$(AS) $(AFLAGS) -Fo./$@ -Fl./$(OBJPATH)$*.lst $<

-include build/clang/watt32.dep

clean:
	- rm -f $(TARGETS) $(OBJPATH)*.obj $(OBJPATH)*.arg $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(RESOURCE)
	@echo Cleaning done

########################################################################

@elifdef HIGHC
#
# Using HighC with GNU-make
#
STAT_LIB  = ../lib/wattcphf.lib
MAKE_FILE = highc.mak
OBJDIR    = build/highc
OBJDIR_   = build\highc
OBJPATH   = $(OBJDIR)/

CC     = hc386
C_ARGS = $(OBJPATH)highc.arg

CFLAGS = -I. -I../inc -I$(PHARLAP)/include -w3 -g -O2 -DWATT32_BUILD \
         -Hpentium_only -DBUGGY_FARPTR=1 -Hnocopyr -Hnoswap          \
         -Hon=relax_func_ptr_rules -Hon=Preload_args_from_memory     \
         -Hon=char_is_rep -Hon=quiet -Hoff=check_stack               \
         -Hon=Recognize_library -Hon=Align_labels -Hoff=Call_trace   \
         -Hpragma=stack_size_warn(10000) -Hoff=Prolog_trace          \
         -Hoff=Epilog_trace -Hpragma=Offwarn(257)                    \
         -Hpragma=Offwarn(572) -Hpragma=Offwarn(578) -Hpragma=Offwarn(491)

AS     = tasm32
AFLAGS = -DDOSX -mx -m2 -t -l
AR     = 386lib -nobanner

TARGETS = $(STAT_LIB)

all: $(PKT_STUB) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS)
	@echo -nowarn -nobackup -twocase -pagesize 32 > $(OBJPATH)lib.arg
	@echo -replace $(OBJS)                       >> $(OBJPATH)lib.arg
	$(AR) $(STAT_LIB) @$(OBJPATH)lib.arg

$(OBJPATH)cpumodel.obj: cpumodel.asm
	$(AS) $(AFLAGS) $<, $(OBJDIR_)\cpumodel.obj

$(OBJPATH)%.obj: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) -o $@ $<

-include $(OBJPATH)watt32.dep

clean:
	rm -f $(TARGETS) $(OBJPATH)*.obj $(OBJPATH)*.arg $(OBJPATH)*.h cpumodel.lst $(PKT_STUB)
	@echo Cleaning done

########################################################################

@elifdef LADSOFT

CC        = $(LADSOFT)\bin\cc386
CFLAGS    = -I. -I..\inc /9 +v -O+a -O+i -C+N -DWATT32_BUILD
AR        = xlib
AS        = tasm32
AFLAGS    = -DDOSX -DDOS4GW -mx -m2 -t -l
MAKE_FILE = ladsoft.mak
STAT_LIB  = ..\lib\wattcplf.lib
OBJDIR    = build\ladsoft
OBJPATH   = $(OBJDIR)\ #

.SWAP

TARGETS = $(STAT_LIB)

all: $(PKT_STUB) $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS)
	$(AR) $(STAT_LIB) @$(OBJPATH)xlib.rsp
	- @del $(STAT_LIB:.lib=.bak)

$(OBJPATH)cpumodel.obj: cpumodel.asm

.c.obj:
	$(CC) -c $(CFLAGS) $*.c -o$(OBJPATH)$*.obj

# .c.obj:
# 	$(CC) -c $(CFLAGS) $*.c -o$(OBJPATH)$*.asm
# 	$(W32_NASM) -s -f obj -l $(OBJPATH)$*.lst -o $(OBJPATH)$*.obj $(OBJPATH)$*.asm

.asm.obj:
	$(AS) $(AFLAGS) $*.asm, $(OBJPATH)$*.obj

!include "build\ladsoft\watt32.dep"

clean:
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)*.asm
	- @del $(OBJPATH)*.lst
	- @del $(TARGETS)
!ifdef PKT_STUB
	- @del $(PKT_STUB)
!endif
	@echo Cleaning done

########################################################################

@elifdef ORANGEC

CC        = $(realpath $(ORANGEC)/bin/occ.exe)
AR        = $(realpath $(ORANGEC)/bin/olib.exe)
RC        = $(realpath $(ORANGEC)/bin/orc.exe)
OLINK     = $(realpath $(ORANGEC)/bin/olink.exe)

STAT_LIB  = ../lib/x86/wattcp_occ.lib
IMP_LIB   = ../lib/x86/wattcp_occ_imp.lib
WATT_DLL  = ../bin/watt-32.dll
EX_LIBS   = user32.lib advapi32.lib

CFLAGS    = -! -I. -I../inc -9 +v -O+a -O+i -w+ -wd148 -DWATT32_BUILD
LDFLAGS   = --nologo --shared -mx -l # -T:WIN32
AS        = $(W32_NASM_)
AFLAGS    = -DBITS_32 -f win32
MAKE_FILE = orangec.mak

OBJDIR    = build/orangec
OBJPATH   = $(OBJDIR)/
C_ARGS    = $(OBJPATH)occ.arg
LINK_ARGS = $(OBJPATH)olink.arg
RESOURCE  = $(OBJPATH)watt-32.res

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS)
	$(AR) --nologo $@ $(subst /,\,$(OBJPATH))*.obj

$(IMP_LIB): $(WATT_DLL)

$(WATT_DLL): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(OLINK) -o $@ $(LDFLAGS) @$(LINK_ARGS) > $(WATT_DLL:.dll=.map)

$(OBJDIR)/cpumodel.obj: cpumodel.nas

$(OBJDIR)/%.obj: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) $*.c -o $@

$(OBJDIR)/%.obj: %.cpp $(C_ARGS)
	$(CC) @$(C_ARGS) -wd110 $*.cpp -o $@

$(OBJDIR)/%.obj: %.nas
	$(AS) $(AFLAGS) -l $(@:.obj=.lst) -o $@ $<

# $(LINK_ARGS): $(MAKE_FILE)
#	@echo $(OBJS) $(RESOURCE) $(EX_LIBS) > $@

-include build/orangec/watt32.dep

clean:
	- @del $(OBJPATH)*.obj
	- @del $(OBJPATH)*.asm
	- @del $(OBJPATH)*.lst
	- @del $(RESOURCE)
	- @del $(TARGETS)
	@echo Cleaning done

########################################################################

@elifdef MINGW32
#
# This section is for the old-school MinGW from 'mingw.org'.
# Will soon history since it's not been updated for years.
#
CC      = gcc
CFLAGS  = -O2 -g -Wall -Wno-strict-aliasing -mthreads -pipe -I. -I../inc \
          -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -DWINVER=0x0601

LDFLAGS = -shared -Wl,--enable-stdcall-fixup,--print-map,--sort-common,--cref

#
# 'as' debug formats:
#
AFLAGS += -gstabs

#
# In the case where 'MinGW32.mak' file is erroneously used to
# build a 64-bit Watt-32 DLL (using e.g. TDM-gcc's "dual-mode" gcc).
# Since in MinGW-w64, 'gcc' w/o '-m32', will generate 64-bit code,
# the result from this makefile is '../bin/watt-32.dll'. And not
# '../bin/watt-32_64.dll'. To build for MinGW-w64 or TDM-gcc, use
# one of these commands:
#   make -f MinGW64_32.mak
#   make -f MinGW64_64.mak
#
# If your gcc/ld/as bundled with the old-school MinGW is too old,
# comment away the '-m32' + '--32' below.
#
CFLAGS  += -m$(BITS)
LDFLAGS += -m$(BITS)
AFLAGS  += --$(BITS)

#
# Just a test
#
CFLAGS += -std=c99

AS       = as
AR       = ar rs
STAT_LIB = ../lib/libwatt32.a
IMP_LIB  = ../lib/libwatt32.dll.a
WATT_DLL = ../bin/watt-32.dll
OBJDIR   = build/MinGW32
OBJPATH  = $(OBJDIR)/
RESOURCE = $(OBJPATH)watt-32.res

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS    = $(OBJPATH)gcc.arg
LIB_ARGS  = $(OBJPATH)ar.arg
LINK_ARGS = $(OBJPATH)ld.arg

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

$(IMP_LIB): $(WATT_DLL)

$(WATT_DLL): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(CC) $(LDFLAGS) -Wl,--out-implib,$(IMP_LIB) -o $@ @$(LINK_ARGS) > $(WATT_DLL:.dll=.map)

$(OBJPATH)cpumodel.o: cpumodel.S

$(OBJPATH)%.o: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) -o $@ $<

$(OBJPATH)%.o: %.S $(C_ARGS)
	$(CC) -E @$(C_ARGS) $< > $(OBJPATH)$*.iS
	$(AS) $(AFLAGS) $(OBJPATH)$*.iS -o $@

-include build/MinGW32/watt32.dep

clean:
	rm -f $(TARGETS) $(OBJPATH)*.o $(OBJPATH)*.iS $(OBJPATH)*.arg $(RESOURCE) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h
	@echo Cleaning done

########################################################################

@elifdef MINGW64

NO_OPT ?= 0
CC      = gcc

ifeq ($(NO_OPT),0)
  CFLAGS = -O2 -g
else
  #
  # 'make NO_OPT=1 -f *.mak' -> tests gcc 5.x with no optimisations
  #                             and old-style inlining.
  #
  CFLAGS = -O0 -g2 -fgnu89-inline
endif

CFLAGS += -Wall -Wundef -Wno-strict-aliasing -I. -I../inc -DWATT32_BUILD -D_WIN32_WINNT=0x0601 -DWINVER=0x0601
LDFLAGS = -shared -Wl,--enable-stdcall-fixup,--print-map,--sort-common,--cref

#
# configur.bat + mkmake.exe generates 2 makefiles for MINGW64:
#  * for 32-bit programs, use MinGW64_32.mak.
#  * for 64-bit programs, use MinGW64_64.mak.
#
# I have tested TDM-gcc [1 + 3] only. [2] may work here too. (And
# there are other MinGW64 packages too).
# For TDM-gcc, 64-bit programs is the default (unless '-m32' is used).
#
# [1] http://tdm-gcc.tdragon.net/
# [2] http://mingw-w64.sourceforge.net/
# [3] https://jmeubank.github.io/tdm-gcc/
#
# And the 'PATH' must have been setup to choose the correct 'gcc.exe'.
#

STAT_LIB = ../lib/$(CPU)/libwatt32.a
IMP_LIB  = ../lib/$(CPU)/libwatt32.dll.a
WATT_DLL = ../bin/watt-32$(SUFFIX).dll

OBJDIR   = build/MinGW64/$(BITS)bit
OBJPATH  = $(OBJDIR)/

CFLAGS  += -m$(BITS)
LDFLAGS += -m$(BITS)
AFLAGS  += --$(BITS) -gstabs

AS       = as
AR       = ar rs
RESOURCE = $(OBJPATH)watt-32.res
EX_LIBS  =

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS    = $(OBJPATH)gcc.arg
LIB_ARGS  = $(OBJPATH)ar.arg
LINK_ARGS = $(OBJPATH)ld.arg

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

$(IMP_LIB): $(WATT_DLL)

$(WATT_DLL): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(CC) $(LDFLAGS) -Wl,--out-implib,$(IMP_LIB) -o $@ @$(LINK_ARGS) > $(WATT_DLL:.dll=.map)

$(OBJPATH)cpumodel.o: cpumodel.S

$(OBJPATH)%.o: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) -o $@ $<

$(OBJPATH)%.o: %.S $(C_ARGS)
	$(CC) -E @$(C_ARGS) $< > $(OBJPATH)$*.iS
	$(AS) $(AFLAGS) $(OBJPATH)$*.iS -o $@

-include build/MinGW64/watt32.dep

clean:
	rm -f $(TARGETS) $(OBJPATH)*.arg $(OBJPATH)*.o $(OBJPATH)*.iS $(RESOURCE) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h
	@echo Cleaning done

########################################################################

@elifdef CYGWIN

CC       = gcc
CFLAGS   = -m$(BITS) -O2 -g -Wall -mthreads -fno-strict-aliasing -static-libgcc -I. -I../inc -DWATT32_BUILD -D_WIN32_WINNT=0x0601
LDFLAGS  = -m$(BITS) -shared -static-libgcc -Wl,--print-map
AS       = as
AFLAGS   = --$(BITS) -ahls

AR       = ar rs
STAT_LIB = ../lib/$(CPU)/libwatt32-cygwin.a
IMP_LIB  = ../lib/$(CPU)/libwatt32-cygwin.dll.a
WATT_DLL = ../bin/watt-32$(SUFFIX).dll
OBJDIR   = ./build/Cygwin/$(BITS)bit
OBJPATH  = $(OBJDIR)/
RESOURCE = $(OBJPATH)watt-32.res

ifeq ($(CPU),x86)
  LDFLAGS += -Wl,--enable-stdcall-fixup
endif

OBJS := $(subst .obj,.o,$(OBJS))

C_ARGS    = $(OBJPATH)gcc.arg
LIB_ARGS  = $(OBJPATH)ar.arg
LINK_ARGS = $(OBJPATH)ld.arg

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS) $(LIB_ARGS)
	$(AR) $@ @$(LIB_ARGS)

$(IMP_LIB): $(WATT_DLL)

$(WATT_DLL): $(OBJS) $(RESOURCE) $(LINK_ARGS)
	$(CC) $(LDFLAGS) -Wl,--out-implib,$(IMP_LIB) -o $@ @$(LINK_ARGS) > $(@:.dll=.map)

$(OBJPATH)cpumodel.o: cpumodel.S

$(OBJPATH)%.o: %.c $(C_ARGS)
	$(CC) @$(C_ARGS) -o $@ $<

$(OBJPATH)%.o: %.S $(C_ARGS)
	$(CC) -E @$(C_ARGS) $< > $(OBJPATH)$*.iS
	$(AS) $(AFLAGS) $(OBJPATH)$*.iS -o $@ > $(OBJPATH)$*.lst

-include build/Cygwin/watt32.dep

clean:
	rm -f $(TARGETS) $(OBJPATH)*.o $(OBJPATH)*.iS $(OBJPATH)*.arg $(RESOURCE) $(OBJPATH)cflags.h $(OBJPATH)cflagsbf.h
	@echo Cleaning done

########################################################################

@elifdef PELLESC

CFLAGS  = -T$(CPU)-coff
LDFLAGS = -machine:$(CPU)

@ifdef WIN64
AS      = ml64
AFLAGS  = -DDOSX -DWIN64
WINLIB  = $(PELLESC)\lib\Win64
@else
AS      = ml
AFLAGS  = -DDOSX -DWIN32 -coff
WINLIB  = $(PELLESC)\lib\Win
@endif

MAKE_FILE = pellesc_$(BITS).mak
OBJDIR    = build\pellesc\$(BITS)bit
OBJPATH   = $(OBJDIR)\ #

CC     = pocc
CFLAGS = $(CFLAGS) -DWATT32_BUILD -MT -X -Ox -Ob1 -Ze -Zi -W1 -Go \
         -I$(PELLESC)\include -I$(PELLESC)\include\win -I. -I..\inc # -std:C99

AFLAGS = -c -nologo -Zi $(AFLAGS)

STAT_LIB = ..\lib\$(CPU)\wattcppo.lib
IMP_LIB  = ..\lib\$(CPU)\wattcppo_imp.lib
WATT_DLL = ..\bin\watt-32$(SUFFIX).dll
RESOURCE = $(OBJPATH)watt-32.res
LDFLAGS  = $(LDFLAGS) -dll -map -libpath:$(PELLESC)\lib -libpath:$(WINLIB) -subsystem:console -debug -verbose
EX_LIBS  = user32.lib kernel32.lib advapi32.lib

TARGETS = $(STAT_LIB) $(IMP_LIB) $(WATT_DLL)

all: $(OBJPATH)cflagsbf.h $(TARGETS)
	@echo All done

$(STAT_LIB): $(OBJS)
	polib -out:$@ $**

$(WATT_DLL) $(IMP_LIB): $(OBJS) $(RESOURCE)
	polink $(LDFLAGS) -out:$(WATT_DLL) -implib:$(IMP_LIB) \
           $** $(EX_LIBS) > link.tmp
	type link.tmp >> $(WATT_DLL:.dll=.map)

$(OBJPATH)cpumodel.obj: cpumodel.asm

.c{$(OBJDIR)}.obj:
	$(CC) -c $(CFLAGS) -Fo$*.obj $<

.asm{$(OBJDIR)}.obj:
	$(AS) $(AFLAGS) -Fo.\$*.obj -Fl.\$*.lst $<

!include build\pellesc\watt32.dep

clean:
	- @del $(TARGETS) $(RESOURCE)
	- @del $(OBJPATH)*.obj $(OBJPATH)*.lst $(OBJPATH)cflagsbf.h
	@echo Cleaning done

@endif

########################################################################

doxygen:
	doxygen doxyfile

lang.c: lang.l
	flex --8bit --stdout lang.l > lang.c

@ifdef HIGHC DJGPP MINGW32 MINGW64 CLANG CYGWIN ORANGEC
  #
  # All these Windows targets uses GNU-make. Hence it should be safe to
  # assume the 'date' program is available.
  #
  DATE = $(shell date +%d-%B-%Y)

  #
  # Extract the GNU-make major version number:
  #
  MAKE_MAJOR_VER = $(word 1, $(subst ., ,$(MAKE_VERSION)))

  ifeq ($(MAKE_MAJOR_VER),4)
    #
    # Create a response file $(1) for GNU-make ver 4.x.
    # One word from $(2) per line into $(1).
    #
    define create_response_file
      $(file > $(1))
      $(foreach f, $(2), $(file >> $(1),$(strip $(f))) )
    endef

    else
    #
    # For a buggy (?) GNU-make. E.g. on MacOS:
    #
    define create_response_file
      rm -f $(1) ; $(foreach f, $(2), echo $(strip $(f)) >> $(1) ;)
    endef
  endif

$(C_ARGS): $(MAKEFILE_LIST)
	$(call create_response_file, $@, -c $(CFLAGS))

$(LIB_ARGS): $(OBJS) $(MAKEFILE_LIST)
	$(call create_response_file, $@, $(OBJS))

@ifdef HIGHC DJGPP
$(LINK_ARGS): $(OBJS) $(MAKEFILE_LIST)
	$(call create_response_file, $@, $(OBJS))
@else
$(LINK_ARGS): $(OBJS) $(RESOURCE) $(MAKEFILE_LIST)
	$(call create_response_file, $@, $(OBJS) $(RESOURCE) $(EX_LIBS))
@endif
@endif

@ifdef HIGHC DJGPP MINGW32 MINGW64 CLANG CYGWIN ORANGEC
  #
  # GNU-Make rules uses shell 'sh' commands:
  #
$(OBJPATH)cflags.h: $(MAKEFILE_LIST)
	echo 'const char *w32_cflags = "$(CFLAGS)";' > $(OBJPATH)cflags.h
	echo 'const char *w32_cc     = "$(CC)";'    >> $(OBJPATH)cflags.h

@elifdef WATCOM
$(OBJPATH)cflags.h: $(__MAKEFILES__)
	%create $^@
	@%append $^@ const char *w32_cflags = "$(CFLAGS)";
	@%append $^@ const char *w32_cc     = "$(CC)";

@elifdef BORLAND
$(OBJPATH)cflags.h: $(MAKE_FILE)
	echo const char *w32_cflags = '"$(CFLAGS)";' > $(OBJPATH)cflags.h
	echo const char *w32_cc     = '"$(CC)";'    >> $(OBJPATH)cflags.h

@else
#
# This is for tools which could possibly not handle all the arguments in
# the 'CFLAGS'. We to do this in several steps creating a multiline string
# for 'w32_cflags'!
#
$(OBJPATH)cflags.h: $(MAKE_FILE)
	echo const char *w32_cflags =       > $(OBJPATH)cflags.h
	echo            "$(CFLAGS)"        >> $(OBJPATH)cflags.h
	echo            "$(EXTRA_CFLAGS);" >> $(OBJPATH)cflags.h
	echo const char *w32_cc = "$(CC)"; >> $(OBJPATH)cflags.h
@endif

@ifdef DJGPP HIGHC
$(OBJPATH)pcpkt.obj: asmpkt.nas
$(OBJPATH)pcpkt.o:   asmpkt.nas

$(PKT_STUB): asmpkt.nas
	$(W32_NASM_) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C_) asmpkt.bin > $@

@elifdef FLAT SMALL32
$(OBJPATH)pcpkt.obj: asmpkt.nas

$(PKT_STUB): asmpkt.nas
	$(W32_NASM) -f bin -l asmpkt.lst -o asmpkt.bin asmpkt.nas
	$(W32_BIN2C) asmpkt.bin > $@

@endif  # FLAT SMALL32

@ifdef WIN32 WIN64
@ifdef DEBUG
DEBUGRC = 1
@else
DEBUGRC = 0
@endif

@ifdef BORLAND
$(RESOURCE): watt-32.rc
	$(BRC32) -DDEBUG=0 -D__BORLANDC__ -r -i..\inc -fo $(RESOURCE) watt-32.rc

@elifdef CLANG
$(RESOURCE): watt-32.rc
	rc -nologo -DRC_DATE="$(DATE)" -DDEBUG=$(DEBUGRC) -D__clang__ -DRC_BITS=$(BITS) -Fo $(RESOURCE) watt-32.rc

@elifdef LCC
$(RESOURCE): watt-32.rc
	lrc -DDEBUG=0 -D__LCC__ -i..\inc -o$(RESOURCE) watt-32.rc

@elifdef MINGW32
$(RESOURCE): watt-32.rc
	windres -DRC_DATE="$(DATE)" --target=pe-i386 -D__MINGW32__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc

@elifdef MINGW64
$(RESOURCE): watt-32.rc
  @ifdef WIN64
	windres -DRC_DATE="$(DATE)" -DRC_BITS=64 --target=pe-x86-64 -D__MINGW64__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc
  @else
	windres -DRC_DATE="$(DATE)" -DRC_BITS=32 --target=pe-i386 -D__MINGW64__ -DDEBUG=0 -O coff -o $@ -i watt-32.rc
  @endif

@elifdef CYGWIN
$(RESOURCE): watt-32.rc
	windres -DRC_DATE="$(DATE)" -DRC_BITS=$(BITS) -I../inc -DDEBUG=0 -D__CYGWIN__ -O coff -o $@ -i watt-32.rc

@elifdef ORANGEC
$(RESOURCE): watt-32.rc
	$(RC) --nologo -DDEBUG=$(DEBUGRC) -D__ORANGEC__ -DRC_BITS=$(BITS) -I..\inc -o $(RESOURCE) watt-32.rc

@elifdef PELLESC
$(RESOURCE): watt-32.rc
	porc -DDEBUG=0 -D__POCC__ -DRC_BITS=$(BITS) -I..\inc -Fo$(RESOURCE) watt-32.rc

@elifdef VISUALC
$(RESOURCE): watt-32.rc
	rc -nologo -DDEBUG=$(DEBUGRC) -D_MSC_VER -DRC_BITS=$(BITS) -Fo $(RESOURCE) watt-32.rc

@elifdef WATCOM
$(RESOURCE): watt-32.rc
	*wrc -q -bt=nt -dDEBUG=0 -D__WATCOMC__ -r -zm -fo=$^@ $<

@endif
@endif  # WIN32 WIN64

#
# Rules for creating 'cflagsbf.h'. A file with a C-array of the 'CFLAGS' used.
# Included in 'version.c'.
#
# '$(W32_BIN2C)' should be set by '.\configur.bat' to point to either
# '..\util\bin2c.exe or '..\util\win32\bin2c.exe'.
#
# And for GNU-make, $(W32_BIN2C_) should be set by '.\configur.bat' to point to either
# '../util/bin2c.exe' or '../util/win32/bin2c.exe'.
#
# PS. 'cflagsbf.h' was previously named 'cflags_buf.h'. But that may cause troubles
#     on plain DOS with only 8+3 files.
#

@ifdef BORLAND
$(OBJPATH)cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)             > $(OBJPATH)cflagsbf.h

@elifdef LADSOFT LCC PELLESC
$(OBJPATH)cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C)    - > $(OBJPATH)cflagsbf.h

@elifdef VISUALC
$(OBJPATH)cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS)             > $(OBJPATH)cflagsbf.h

@elifdef CYGWIN MINGW32 MINGW64 ORANGEC
$(OBJPATH)cflagsbf.h:
	echo $(CFLAGS) | $(W32_BIN2C_)   - > $(OBJPATH)cflagsbf.h

@elifdef HIGHC
$(OBJPATH)cflagsbf.h:
	echo "$(CFLAGS)" | $(W32_BIN2C_) - > $(OBJPATH)cflagsbf.h

@elifdef WATCOM
$(OBJPATH)cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C) $(C_ARGS) > $^@

@elifdef CLANG
$(OBJPATH)cflagsbf.h: $(C_ARGS)
	$(W32_BIN2C_) $(C_ARGS) > $@

@endif

@ifdef HIGHC DJGPP MINGW32 MINGW64 CLANG CYGWIN CLANG
#
# Preprocess a .c-file and pipe through 'Astyle' to beautify it.
#
%.i: %.c
	@echo "Preprocessed result of $< with these CFLAGS:"    > $@
	cat $(C_ARGS)                                          >> $@
	@echo "----------------------------------------------" >> $@
	$(CC) -E @$(C_ARGS) $< | astyle >> $@
	@echo

DEP_REPLACE = sed -e 's/\(.*\)\.o: /\n$$(OBJPATH)\1.o: /' \
                  -e 's@/cygdrive/@:@'

DEP_FILE = $(OBJPATH)watt-32.dep

depend: $(OBJPATH)cflags.h
	$(CC) -MM $(CFLAGS) $(C_SOURCE) | $(DEP_REPLACE) > $(DEP_FILE)

#
# This is not the file generated by 'configur.bat', but the above 'depend' rule.
#
-include $(DEP_FILE)

@endif
